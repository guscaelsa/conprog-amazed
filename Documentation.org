#+TITLE: Amazed Documentation
#+AUTHOR: Matthijs de Vries and Elsa Carlsson
#+OPTIONS: TOC:nil ':t

* Data structures
The parallel search uses the same three data structures as the sequential one: a frontier stack, a "visited" set, and a predecessor-map.

The frontier stack is entirely local; every thread is searching through one part of the maze independently. Therefore it can continue to simply be a ~Stack~.

To prevent multiple threads from visited the same node, the visited-set must be shared. The most natural choice for this is ~java.util.concurrent.ConcurrentSkipListSet~.

The predecessor-map also does not need to be shared, each thread only needs to know how to get to its part of the maze. However, the map does need to be inherited by child threads as they need to know how their parent got to where it starts. But that is simple enough to do with a ~HashMap~.

* Algorithm
+ Start by pushing the start node onto the frontier stack.
+ Until the frontier becomes empty:
  + Pop a "current" node from the frontier
  + Try to visit the current node, else continue loop
  + If current is a goal:
    + Set termination flag
    + Return the found path
  + Otherwise, loop through all neighbors:
    + If termination flag is set, break out of (inner) loop
    + If this neighbor is already in the predecessor map, continue (inner) loop
    + Update predecessor map
    + Either: fork a child
    + Or: push to frontier
  + If termination flag is set, break out of loop
+ Loop through all children:
  + Join the child and look at its result
  + If it found a path, return that
+ return null

# Trying to visit a node
# Termination flag
# Forking decision
# Forking

* Synchronization
The threads are synchronized using two objects: the visited-map and the termination flag. These are a ~java.util.concurrent.ConcurrentSkipListSet~ and a ~java.util.concurrent.atomic.AtomicBoolean~ respectively.

These classes are lock-free, and since we don't use any other synchronization our search is also lock-free.

When a thread tries to visit a node, we call ~visited.add(current)~ and checks the returned boolean to see if we were allowed. This means that getting permission and blocking all other threads is atomic, so only a single thread will be allowed to visit any given node. In other words, there are no data races in how we use ~ConcurrentSkipListSet~.

And the ~AtomicBoolean~ is just used as a simple flag; it starts of false and is eventually set to true. All threads then monitor this and shut down as soon as it becomes true. Because we in no way rely on when this happens (the flag will eventually be set and the threads will eventually look), there are no data races possible.

In fact we could probably just use a raw ~boolean~ (without ~volatile~) for the terminate flag, and just wait for the value to eventually be updated. In fact, in my limited tests this vastly outperforms using an ~AtomicBoolean~.
* --- :noexport:

#+BEGIN_SRC java
        int count = 0;
        int player = maze.newPlayer(start);
        frontier.push(start);

        while (!frontier.empty()) {
            int current = frontier.pop();

            if (visited.add(current)) { // "true if this set did not already contain the specified element"
                maze.move(player, current);

                if (maze.hasGoal(current)) {
                    shutdown.set(true);
                    return pathFromTo(maze.start(), current);
                }

                for (int nb: maze.neighbors(current)) {
                    if (shutdown.get()) {
                        break;
                    }

                    predecessor.put(nb, current);

                    if (count >= forkAfter /*should fork?*/) {
                        ForkJoinSolver child = new ForkJoinSolver(maze, visited, predecessor, nb, shutdown, forkAfter);
                        children.add(child);
                        child.fork();
                        count = 0;
                    } else {
                        frontier.push(nb);
                        count++;
                    }
                }
            }
            if (shutdown.get()) {
                break;
            }
        }
        // all nodes explored, wait for children
        for (ForkJoinSolver child : children) {
            List<Integer> result = child.join();
            if (result != null) {
                return result;
            }
        }
        // no goal found
        return null;
    }
#+END_SRC

Starting with the shared resources we realized that the visited set has to be a shared resource and thus thread safe
this was easliy done by using the ConcurrentSkipList class. the frontier stack is completely local and the predecessors 
are all merged together when the forks join back together. For our solution we made an additional constructor taking all variables. 
In the ParallelSearch method we basically followed the instructions given to us. We pop a node from frontiers. Check that it's not empty, 
'check if it has been visited, if not add the node to the visited set and move the player, if the goal has been found we use the pathFromTo given to us.
To make sure all forks stop we introduced a global flag (included in the constructor) which is set to true when a goal has been found 
or when all nodes have been explored. once on a node, each neighbour is checked. this is where we fork using the forkAfter variable and a simple counter 
to keep track of when to fork. When all nodes are explored we join together all forks and return the result or null if no goal was found.


from requirements:

discuss race condition and data races

discuss lock-free(ness)
